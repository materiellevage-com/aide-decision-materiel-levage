<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Aide au choix ‚Äî Levage | MATERIEL-LEVAGE</title>
  <meta name="description" content="Parcours guid√© pour qualifier un besoin de levage √† travers une conversation simple, et g√©n√©rer un cahier des charges." />

  <style>
    :root{
      /* Structure (proche visuels) */
      --ml-blue:#2a2e86;
      --ml-blue-dark:#1f2268;
      --ml-yellow:#f2c200;
      --ml-bg:#f5f6fb;
      --ml-card:#ffffff;
      --ml-text:#111827;
      --ml-muted:#6b7280;
      --ml-line:#e5e7eb;
      --ml-shadow:0 10px 25px rgba(17,24,39,.10);
      --ml-radius:16px;

      /* Cat√©gories catalogue (r√©serv√©es √† la charte, pas aux textes d'orientation) */
      --cat-accessories:#b10f1b;  /* rouge accessoires */
      --cat-magnets:#22a35a;      /* vert aimants */
      --cat-site:#2b77d9;         /* bleu clair chantier */
      --cat-hoists:#f28c00;       /* orange palans */

      --good:#16a34a;
      --warn:#f59e0b;
      --bad:#dc2626;
      --font: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    *{box-sizing:border-box}
    body{margin:0;font-family:var(--font);color:var(--ml-text);background:var(--ml-bg)}
    .wrap{max-width:1100px;margin:0 auto;padding:14px}

    /* Header */
    .topbar{
      background:#fff;
      border-bottom:4px solid var(--cat-accessories);
      box-shadow: 0 6px 20px rgba(17,24,39,.08);
      position:sticky;top:0;z-index:50;
    }
    .topbar-inner{
      max-width:1100px;margin:0 auto;padding:10px 14px;
      display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;
    }
    .brand{display:flex;align-items:center;gap:12px}
    .logo{
      display:flex;align-items:center;gap:8px;
      font-weight:900;font-size:18px;color:var(--ml-blue);
      white-space:nowrap;
    }
    .logo .dot{
      width:34px;height:34px;border-radius:10px;
      background: radial-gradient(circle at 30% 30%, var(--ml-yellow), #ffd84a);
      border:1px solid rgba(0,0,0,.08);
      display:grid;place-items:center;
      color:var(--ml-blue-dark);font-weight:1000;
    }
    .logo .site{display:flex;align-items:baseline;gap:2px}
    .logo .com{color:var(--ml-yellow);font-weight:1000}
    .subtitle{color:var(--ml-muted);font-size:12px;line-height:1.3}

    .top-actions{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end}
    .pill{
      display:inline-flex;align-items:center;gap:8px;
      padding:7px 10px;border-radius:999px;background:#fff;border:1px solid var(--ml-line);
      font-size:12px;font-weight:800;color:#111827;
    }
    .pill b{color:var(--ml-blue)}
    .statusDot{width:10px;height:10px;border-radius:999px;background:var(--warn)}
    .statusDot.good{background:var(--good)}
    .statusDot.warn{background:var(--warn)}
    .statusDot.bad{background:var(--bad)}

    /* Layout */
    .grid{display:grid;grid-template-columns:1.05fr .95fr;gap:14px;margin-top:14px}
    @media (max-width:980px){.grid{grid-template-columns:1fr}}

    .card{
      background:var(--ml-card);
      border:1px solid var(--ml-line);
      border-radius:var(--ml-radius);
      box-shadow:var(--ml-shadow);
      overflow:hidden;
    }
    .card .hd{
      padding:12px 14px;border-bottom:1px solid var(--ml-line);
      display:flex;align-items:flex-start;justify-content:space-between;gap:10px;flex-wrap:wrap;
      background:#fff;
    }
    .card .hd h2{margin:0;font-size:14px;font-weight:1000;color:var(--ml-blue-dark)}
    .card .hd p{margin:6px 0 0;color:var(--ml-muted);font-size:12px;line-height:1.4}
    .card .bd{padding:14px}

    /* Conversation */
    .chatTitle{
      font-weight:1000;color:#111827;font-size:14px;margin:0 0 6px;
    }
    .chatHint{color:var(--ml-muted);font-size:12px;line-height:1.45;margin:0}
    .progressRow{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:10px}

    .questionBox{
      border:1px solid var(--ml-line);
      border-radius:16px;
      padding:14px;
      background:#fff;
    }
    .askRow{display:flex;align-items:flex-start;justify-content:space-between;gap:10px}
    .ask{
      margin:0;
      font-size:14px;
      font-weight:1000;
      color:#111827;
      line-height:1.35;
    }
    .askSub{margin:6px 0 0;color:var(--ml-muted);font-size:12px;line-height:1.45}

    .tip{
      position:relative;width:28px;height:28px;border-radius:999px;
      border:1px solid var(--ml-line);background:#fff;
      display:grid;place-items:center;font-weight:1000;color:var(--ml-blue-dark);
      cursor:help;flex:0 0 auto;
    }
    .bubble{
      position:absolute;right:0;top:calc(100% + 10px);
      width:min(440px, calc(100vw - 40px));
      background:#fff;border:1px solid var(--ml-line);
      border-radius:14px;box-shadow:var(--ml-shadow);
      padding:12px;display:none;z-index:60;
    }
    .tip:hover .bubble{display:block}
    .bubble .t{margin:0 0 6px;font-size:12px;font-weight:1000;color:#111827}
    .bubble .p{margin:0;color:var(--ml-muted);font-size:12px;line-height:1.45}

    .opts{display:grid;gap:10px;margin-top:12px}
    .opt{
      display:flex;gap:10px;align-items:flex-start;
      padding:12px;border-radius:14px;border:1px solid var(--ml-line);
      background:#fff;transition:.12s;
    }
    .opt:hover{border-color:#d1d5db;background:#fcfcff}
    .opt input{margin-top:2px;transform:scale(1.08)}
    .opt label{cursor:pointer;flex:1}
    .opt b{display:block;font-size:14px}
    .opt .small{display:block;color:var(--ml-muted);font-size:12px;margin-top:2px;line-height:1.35}

    .actions{
      display:flex;gap:10px;flex-wrap:wrap;align-items:center;
      margin-top:14px;
    }
    .btn{
      appearance:none;border:1px solid var(--ml-line);background:#fff;color:#111827;
      border-radius:12px;padding:10px 12px;font-size:13px;font-weight:900;
      cursor:pointer;transition:.12s;
    }
    .btn:hover{background:#f9fafb}
    .btn.core{
      border-color: rgba(42,46,134,.25);
      background: rgba(42,46,134,.08);
      color: var(--ml-blue-dark);
    }
    .btn.core:hover{background: rgba(42,46,134,.11)}
    .btn.neutral{
      border-color: rgba(107,114,128,.25);
      background: rgba(107,114,128,.07);
      color: #111827;
    }
    .btn.neutral:hover{background: rgba(107,114,128,.10)}
    .btn.danger{
      border-color: rgba(177,15,27,.40);
      background: rgba(177,15,27,.10);
      color: #7a0b12;
    }
    .btn.danger:hover{background: rgba(177,15,27,.14)}

    .mini{color:var(--ml-muted);font-size:12px;line-height:1.45;margin-top:8px}

    /* Right column */
    table{width:100%;border-collapse:collapse}
    th,td{padding:10px;border-bottom:1px solid var(--ml-line);vertical-align:top}
    th{font-size:12px;color:var(--ml-muted);text-align:left}
    td{font-size:13px}

    .mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:12px;background:#fbfbff;border:1px solid var(--ml-line);
      border-radius:14px;padding:12px;white-space:pre-wrap;color:#0f172a;
    }
    ul{margin:10px 0 0;padding-left:18px;color:var(--ml-muted);font-size:12px;line-height:1.55}

    .divider{height:1px;background:var(--ml-line);margin:12px 0}
  </style>
</head>

<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <div class="logo">
          <div class="dot">ML</div>
          <div class="site">
            <span>MATERIEL-LEVAGE</span><span class="com">.com</span>
          </div>
        </div>
        <div>
          <div style="font-weight:1000;color:var(--ml-blue-dark)">Aide au choix ‚Äî discussion guid√©e</div>
          <div class="subtitle">R√©pondez comme √† un sp√©cialiste : on qualifie votre besoin, puis on g√©n√®re votre cahier des charges.</div>
        </div>
      </div>

      <div class="top-actions">
        <span class="pill"><span class="statusDot warn" id="dot"></span><span id="statusTxt">√Ä compl√©ter</span></span>
        <span class="pill">Pr√©cision : <b id="clarityTxt">100%</b></span>
        <button class="btn" id="resetBtn" type="button">R√©initialiser</button>
        <button class="btn core" id="demoBtn" type="button">Pr√©remplir d√©mo</button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="grid">

      <!-- Conversation -->
      <div class="card">
        <div class="hd">
          <div>
            <h2>Questions (une √† la fois)</h2>
            <p>Validez votre r√©ponse pour passer √† la suite. Si vous ne savez pas, utilisez le bouton d√©di√©.</p>
          </div>
        </div>

        <div class="bd">
          <div class="questionBox" id="questionBox">
            <div class="askRow">
              <div>
                <p class="ask" id="ask">‚Äî</p>
                <p class="askSub" id="askSub">‚Äî</p>
                <div class="progressRow">
                  <span class="pill" id="stepPill"><b id="stepTxt">1</b> / 5</span>
                  <span class="pill">R√©ponses donn√©es : <b id="answeredTxt">0</b></span>
                </div>
              </div>
              <div class="tip">i
                <div class="bubble">
                  <p class="t" id="tipTitle">Aide</p>
                  <p class="p" id="tipText">‚Äî</p>
                </div>
              </div>
            </div>

            <div class="opts" id="opts"></div>

            <div class="actions">
              <button class="btn core" id="validateBtn" type="button">Valider ma r√©ponse</button>
              <button class="btn neutral" id="dontKnowBtn" type="button">Je ne sais pas</button>
              <button class="btn" id="backBtn" type="button">Retour</button>
              <button class="btn" id="skipToSummaryBtn" type="button">Voir la synth√®se</button>
            </div>

            <div class="mini" id="msg"></div>
          </div>
        </div>
      </div>

      <!-- Synth√®se -->
      <div class="card">
        <div class="hd">
          <div>
            <h2>Synth√®se & Cahier des charges</h2>
            <p>La pr√©cision baisse si certaines r√©ponses ne sont pas connues.</p>
          </div>
        </div>
        <div class="bd">
          <table>
            <thead><tr><th>√âl√©ment</th><th>Votre r√©ponse</th></tr></thead>
            <tbody id="summary"></tbody>
          </table>

          <div class="divider"></div>

          <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center">
            <div style="font-weight:1000;color:var(--ml-blue-dark)">Cahier des charges (copiable)</div>
            <div class="mini" id="complexity">‚Äî</div>
          </div>
          <div class="mono" id="cdc">‚Äî</div>

          <div class="actions" style="margin-top:12px">
            <button class="btn core" id="copyBtn" type="button">Copier</button>
            <button class="btn" id="downloadBtn" type="button">T√©l√©charger (.txt)</button>
            <button class="btn danger" id="callBtn" type="button">Contacter un sp√©cialiste</button>
          </div>

          <ul id="alerts"></ul>
        </div>
      </div>

    </div>
  </div>

  <script>
    const $ = (id)=>document.getElementById(id);

    // Questions (sans Q1/Q2 visibles)
    // "dontKnow" est g√©r√© par le bouton, pas dans les r√©ponses.
    const flow = [
      {
        id:"action",
        title:"Pour commencer : qu‚Äôavez-vous besoin de faire avec la charge ?",
        sub:"Vous pouvez choisir plusieurs actions si besoin.",
        tipTitle:"Aide ‚Äî Action",
        tip:"On d√©crit ce que vous faites r√©ellement : lever, d√©placer, accrocher/saisir, ou pr√©voir une structure.",
        type:"multi",
        options:[
          { id:"lift", label:"Lever la charge", help:"Soulever verticalement (mont√©e / descente)." },
          { id:"move", label:"D√©placer la charge", help:"D√©placer lat√©ralement ou vers plusieurs positions." },
          { id:"hook", label:"Accrocher / saisir la charge", help:"Mettre la charge en prise pour la lever ou la maintenir." },
          { id:"support", label:"Supporter l‚Äôop√©ration", help:"Pr√©voir une structure (potence/portique‚Ä¶) pour porter l‚Äôappareil." }
        ]
      },
      {
        id:"movement",
        title:"Concernant le mouvement : quel type de d√©placement est attendu ?",
        sub:"Si vous ne d√©placez pas la charge, vous pouvez passer rapidement.",
        tipTitle:"Aide ‚Äî Mouvement",
        tip:"Plus le mouvement est complexe (inclinaison/retournement), plus la s√©lection doit √™tre valid√©e.",
        type:"single",
        gate:(state)=> state.action?.includes("move") === true,
        options:[
          { id:"vonly", label:"Verticalement uniquement", help:"Mont√©e/descente sans translation lat√©rale." },
          { id:"h1", label:"Horizontal ‚Äî une direction", help:"Translation sur un axe." },
          { id:"hmulti", label:"Horizontal ‚Äî plusieurs directions", help:"Plusieurs positions dans la zone." },
          { id:"tilt", label:"Incliner / basculer", help:"Positionnement par inclinaison." },
          { id:"flip", label:"Retourner la charge", help:"Retournement complet (180¬∞)." }
        ]
      },
      {
        id:"location",
        title:"O√π se d√©roule l‚Äôop√©ration ?",
        sub:"Choisissez ce qui correspond le mieux, puis indiquez si c‚Äôest multi-sites.",
        tipTitle:"Aide ‚Äî Localisation",
        tip:"La localisation influence souvent l‚Äôinstallation et le type de support ou de mobilit√©.",
        type:"mixed",
        optionsRadio:[
          { id:"station", label:"Un poste de travail d√©di√©", help:"Toujours au m√™me endroit." },
          { id:"zone", label:"Une zone de travail d√©finie", help:"D√©placements sur plusieurs m√®tres." },
          { id:"multi", label:"Plusieurs postes / zones", help:"Emplacements distincts." }
        ],
        optionCheck:{ id:"multisite", label:"Option : multi-sites", help:"Ateliers / b√¢timents / sites diff√©rents." },
        gate:(state)=> (state.action?.includes("lift") || state.action?.includes("move")) === true
      },
      {
        id:"hooking",
        title:"Comment la charge peut-elle √™tre prise (accrochage / saisie) ?",
        sub:"Dites-nous si la charge a des points d‚Äôancrage d√©di√©s, ou si elle doit √™tre prise autrement.",
        tipTitle:"Aide ‚Äî Accrochage",
        tip:"Avec ancrages : nombre de points + centre de gravit√©. Sans ancrages : pince/ventouse/aimant selon le cas.",
        type:"branch",
        gate:(state)=> state.action?.includes("hook") === true,
        first:[
          { id:"has", label:"La charge a des points d‚Äôancrage", help:"Anneaux, anses, points pr√©vus/valid√©s." },
          { id:"none", label:"La charge n‚Äôa pas de points d‚Äôancrage", help:"Prise par pince, ventouse, aimant, etc." }
        ],
        branchHas:{
          points:[
            { id:"p1", label:"1 point", help:"Accrochage simple." },
            { id:"p2", label:"2 points", help:"R√©partition √† v√©rifier." },
            { id:"p3", label:"3 points", help:"R√©glage souvent n√©cessaire." },
            { id:"p4", label:"4 points", help:"Angles critiques : validation recommand√©e." }
          ],
          dedicated:{ id:"dedicated", label:"Option : points d√©di√©s au levage", help:"Points pr√©vus/valid√©s par le fabricant." },
          cg:[
            { id:"center", label:"Centre de gravit√© centr√©", help:"Stabilit√© naturelle." },
            { id:"above_off", label:"Centre de gravit√© d√©centr√©", help:"Inclinaison possible." },
            { id:"below", label:"Centre de gravit√© sous les ancrages", help:"Risque de basculement / retournement." }
          ]
        },
        branchNone:{
          grip:[
            { id:"positive", label:"Prise positive", help:"Accrochage m√©canique par forme." },
            { id:"clamp", label:"Serrage (pince)", help:"Maintien par pression." },
            { id:"suction", label:"Ventouses", help:"Surface compatible, √©tanch√©it√©." },
            { id:"mag", label:"Aimants", help:"Uniquement ferromagn√©tique." }
          ],
          stab:[
            { id:"stable", label:"Charge stable", help:"Peu de risque d‚Äôinclinaison." },
            { id:"sensitive", label:"Charge sensible", help:"Peut s‚Äôincliner." },
            { id:"unstable", label:"Charge instable", help:"Risque fort de basculement." }
          ]
        }
      },
      {
        id:"quality",
        title:"Quel niveau de pr√©cision attendez-vous pendant la manutention ?",
        sub:"Cela aide √† d√©finir la ma√Ætrise de vitesse, le ballant, et la stabilit√©.",
        tipTitle:"Aide ‚Äî Pr√©cision",
        tip:"Plus c‚Äôest pr√©cis, plus la solution devra ma√Ætriser les √†-coups et le ballant.",
        type:"single",
        gate:(state)=> (state.action?.includes("lift") || state.action?.includes("move") || state.action?.includes("hook")) === true,
        options:[
          { id:"simple", label:"Simple", help:"Positionnement approximatif acceptable." },
          { id:"precise", label:"Pr√©cise", help:"Sans √†-coups, ballant limit√©." },
          { id:"very", label:"Tr√®s pr√©cise", help:"Contr√¥le permanent, ballant quasi nul." }
        ]
      }
    ];

    // State + scoring
    const state = {};
    const dontKnowCount = { total:0, byId:{} };

    let stepIndex = 0;
    const visibleSteps = []; // steps taking gates into account

    function buildVisibleSteps(){
      visibleSteps.length = 0;
      flow.forEach((q, idx)=>{
        const ok = q.gate ? q.gate(state) : true;
        if(ok) visibleSteps.push(idx);
      });
      // Ensure stepIndex is valid
      if(stepIndex >= visibleSteps.length) stepIndex = visibleSteps.length - 1;
      if(stepIndex < 0) stepIndex = 0;
    }

    function answeredCount(){
      let n = 0;
      for(const k of Object.keys(state)){
        if(state[k] !== null && state[k] !== undefined) n++;
      }
      return n;
    }

    // Precision score: starts at 100, decreases with dontKnow + missing requireds
    function precisionScore(){
      let score = 100;

      // penalty per "Je ne sais pas"
      score -= dontKnowCount.total * 10;

      // penalty for missing key items (soft)
      if(!state.action || state.action.length===0) score -= 40;

      if(state.action?.includes("move") && !state.movement) score -= 10;
      if((state.action?.includes("lift") || state.action?.includes("move")) && !state.location) score -= 10;

      if(state.action?.includes("hook") && !state.hooking) score -= 18;

      if((state.action?.includes("lift") || state.action?.includes("move") || state.action?.includes("hook")) && !state.quality) score -= 8;

      score = Math.max(0, Math.min(100, Math.round(score)));
      return score;
    }

    function statusFromScore(score){
      if(score >= 85) return { txt:"Demande bien qualifi√©e", dot:"good" };
      if(score >= 65) return { txt:"Demande √† pr√©ciser", dot:"warn" };
      return { txt:"Besoin √† cadrer", dot:"bad" };
    }

    function complexity(){
      // simple heuristic
      if(state.movement === "flip") return "Complexit√© : Hors standard";
      if(state.movement === "tilt") return "Complexit√© : Complexe";
      if(state.quality === "very") return "Complexit√© : Complexe";
      return "Complexit√© : Mod√©r√©e";
    }

    function esc(s){
      return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;").replaceAll("'","&#039;");
    }

    function setHeader(){
      const score = precisionScore();
      const st = statusFromScore(score);
      $("clarityTxt").textContent = score + "%";
      $("statusTxt").textContent = st.txt;
      $("dot").className = "statusDot " + st.dot;
    }

    function setStepPills(){
      $("stepTxt").textContent = String(stepIndex + 1);
      $("stepPill").innerHTML = `<b>${stepIndex + 1}</b> / ${visibleSteps.length}`;
      $("answeredTxt").textContent = String(answeredCount());
    }

    function renderCurrent(){
      buildVisibleSteps();
      setHeader();
      setStepPills();
      $("msg").textContent = "";

      const q = flow[ visibleSteps[stepIndex] ];

      $("ask").textContent = q.title;
      $("askSub").textContent = q.sub || "";
      $("tipTitle").textContent = q.tipTitle || "Aide";
      $("tipText").textContent = q.tip || "";

      const opts = $("opts");
      opts.innerHTML = "";

      // Build UI per type
      if(q.type === "multi"){
        q.options.forEach(o=>{
          const id = `opt_${q.id}_${o.id}`;
          const checked = (state[q.id] || []).includes(o.id);
          opts.insertAdjacentHTML("beforeend", `
            <div class="opt">
              <input type="checkbox" id="${id}" ${checked ? "checked":""}>
              <label for="${id}">
                <b>${esc(o.label)}</b>
                <span class="small">${esc(o.help || "")}</span>
              </label>
            </div>
          `);
        });
      }

      if(q.type === "single"){
        q.options.forEach(o=>{
          const id = `opt_${q.id}_${o.id}`;
          const checked = state[q.id] === o.id;
          opts.insertAdjacentHTML("beforeend", `
            <div class="opt">
              <input type="radio" name="radio_${q.id}" id="${id}" ${checked ? "checked":""}>
              <label for="${id}">
                <b>${esc(o.label)}</b>
                <span class="small">${esc(o.help || "")}</span>
              </label>
            </div>
          `);
        });
      }

      if(q.type === "mixed"){
        // radio group
        q.optionsRadio.forEach(o=>{
          const id = `opt_${q.id}_${o.id}`;
          const checked = state[q.id] === o.id;
          opts.insertAdjacentHTML("beforeend", `
            <div class="opt">
              <input type="radio" name="radio_${q.id}" id="${id}" ${checked ? "checked":""}>
              <label for="${id}">
                <b>${esc(o.label)}</b>
                <span class="small">${esc(o.help || "")}</span>
              </label>
            </div>
          `);
        });
        // single checkbox option (no warning label underneath, as requested)
        const oc = q.optionCheck;
        const cid = `opt_${q.id}_${oc.id}`;
        const cchecked = !!(state[`${q.id}_${oc.id}`]);
        opts.insertAdjacentHTML("beforeend", `
          <div class="opt">
            <input type="checkbox" id="${cid}" ${cchecked ? "checked":""}>
            <label for="${cid}">
              <b>${esc(oc.label)}</b>
              <span class="small">${esc(oc.help || "")}</span>
            </label>
          </div>
        `);
      }

      if(q.type === "branch"){
        // First choice
        q.first.forEach(o=>{
          const id = `opt_${q.id}_first_${o.id}`;
          const checked = (state[q.id]?.mode === o.id);
          opts.insertAdjacentHTML("beforeend", `
            <div class="opt">
              <input type="radio" name="radio_${q.id}_first" id="${id}" ${checked ? "checked":""}>
              <label for="${id}">
                <b>${esc(o.label)}</b>
                <span class="small">${esc(o.help || "")}</span>
              </label>
            </div>
          `);
        });

        // Branch details if selected
        const mode = state[q.id]?.mode;
        if(mode === "has"){
          opts.insertAdjacentHTML("beforeend", `<div class="divider"></div>`);

          q.branchHas.points.forEach(o=>{
            const id = `opt_${q.id}_points_${o.id}`;
            const checked = (state[q.id]?.points === o.id);
            opts.insertAdjacentHTML("beforeend", `
              <div class="opt">
                <input type="radio" name="radio_${q.id}_points" id="${id}" ${checked ? "checked":""}>
                <label for="${id}">
                  <b>${esc(o.label)}</b>
                  <span class="small">${esc(o.help || "")}</span>
                </label>
              </div>
            `);
          });

          const did = `opt_${q.id}_dedicated_${q.branchHas.dedicated.id}`;
          const dchecked = !!(state[q.id]?.dedicated);
          opts.insertAdjacentHTML("beforeend", `
            <div class="opt">
              <input type="checkbox" id="${did}" ${dchecked ? "checked":""}>
              <label for="${did}">
                <b>${esc(q.branchHas.dedicated.label)}</b>
                <span class="small">${esc(q.branchHas.dedicated.help || "")}</span>
              </label>
            </div>
          `);

          opts.insertAdjacentHTML("beforeend", `<div class="divider"></div>`);

          q.branchHas.cg.forEach(o=>{
            const id = `opt_${q.id}_cg_${o.id}`;
            const checked = (state[q.id]?.cg === o.id);
            opts.insertAdjacentHTML("beforeend", `
              <div class="opt">
                <input type="radio" name="radio_${q.id}_cg" id="${id}" ${checked ? "checked":""}>
                <label for="${id}">
                  <b>${esc(o.label)}</b>
                  <span class="small">${esc(o.help || "")}</span>
                </label>
              </div>
            `);
          });
        }

        if(mode === "none"){
          opts.insertAdjacentHTML("beforeend", `<div class="divider"></div>`);

          q.branchNone.grip.forEach(o=>{
            const id = `opt_${q.id}_grip_${o.id}`;
            const checked = (state[q.id]?.grip === o.id);
            opts.insertAdjacentHTML("beforeend", `
              <div class="opt">
                <input type="radio" name="radio_${q.id}_grip" id="${id}" ${checked ? "checked":""}>
                <label for="${id}">
                  <b>${esc(o.label)}</b>
                  <span class="small">${esc(o.help || "")}</span>
                </label>
              </div>
            `);
          });

          opts.insertAdjacentHTML("beforeend", `<div class="divider"></div>`);

          q.branchNone.stab.forEach(o=>{
            const id = `opt_${q.id}_stab_${o.id}`;
            const checked = (state[q.id]?.stab === o.id);
            opts.insertAdjacentHTML("beforeend", `
              <div class="opt">
                <input type="radio" name="radio_${q.id}_stab" id="${id}" ${checked ? "checked":""}>
                <label for="${id}">
                  <b>${esc(o.label)}</b>
                  <span class="small">${esc(o.help || "")}</span>
                </label>
              </div>
            `);
          });
        }
      }

      // Back button visibility
      $("backBtn").style.display = (stepIndex === 0) ? "none" : "inline-block";
    }

    function collectCurrentAnswer(){
      const q = flow[ visibleSteps[stepIndex] ];

      if(q.type === "multi"){
        const selected = [];
        q.options.forEach(o=>{
          const id = `opt_${q.id}_${o.id}`;
          const el = $(id);
          if(el && el.checked) selected.push(o.id);
        });
        return selected;
      }

      if(q.type === "single"){
        let picked = null;
        q.options.forEach(o=>{
          const id = `opt_${q.id}_${o.id}`;
          const el = $(id);
          if(el && el.checked) picked = o.id;
        });
        return picked;
      }

      if(q.type === "mixed"){
        let picked = null;
        q.optionsRadio.forEach(o=>{
          const id = `opt_${q.id}_${o.id}`;
          const el = $(id);
          if(el && el.checked) picked = o.id;
        });
        const ck = $(`opt_${q.id}_${q.optionCheck.id}`)?.checked || false;
        return { radio:picked, check:ck };
      }

      if(q.type === "branch"){
        const out = { mode:null, points:null, dedicated:false, cg:null, grip:null, stab:null };

        // first
        q.first.forEach(o=>{
          const id = `opt_${q.id}_first_${o.id}`;
          const el = $(id);
          if(el && el.checked) out.mode = o.id;
        });

        if(out.mode === "has"){
          q.branchHas.points.forEach(o=>{
            const id = `opt_${q.id}_points_${o.id}`;
            const el = $(id);
            if(el && el.checked) out.points = o.id;
          });
          out.dedicated = $(`opt_${q.id}_dedicated_${q.branchHas.dedicated.id}`)?.checked || false;

          q.branchHas.cg.forEach(o=>{
            const id = `opt_${q.id}_cg_${o.id}`;
            const el = $(id);
            if(el && el.checked) out.cg = o.id;
          });
        }

        if(out.mode === "none"){
          q.branchNone.grip.forEach(o=>{
            const id = `opt_${q.id}_grip_${o.id}`;
            const el = $(id);
            if(el && el.checked) out.grip = o.id;
          });
          q.branchNone.stab.forEach(o=>{
            const id = `opt_${q.id}_stab_${o.id}`;
            const el = $(id);
            if(el && el.checked) out.stab = o.id;
          });
        }

        return out;
      }

      return null;
    }

    function saveAnswer(answer, isDontKnow=false){
      const q = flow[ visibleSteps[stepIndex] ];

      if(isDontKnow){
        // Do not overwrite existing answer; just mark dontKnow and keep null if empty
        dontKnowCount.total += 1;
        dontKnowCount.byId[q.id] = (dontKnowCount.byId[q.id] || 0) + 1;
        // ensure key exists as null if not present
        if(state[q.id] === undefined) state[q.id] = null;
        // for mixed: store null + checkbox separately
        if(q.type==="mixed"){
          if(state[q.id] === undefined) state[q.id] = null;
          if(state[`${q.id}_${q.optionCheck.id}`] === undefined) state[`${q.id}_${q.optionCheck.id}`] = false;
        }
        return true;
      }

      // Normal save
      if(q.type==="mixed"){
        state[q.id] = answer.radio;
        state[`${q.id}_${q.optionCheck.id}`] = !!answer.check;
        return true;
      }

      state[q.id] = answer;
      return true;
    }

    function next(){
      buildVisibleSteps();
      if(stepIndex < visibleSteps.length - 1){
        stepIndex += 1;
        renderCurrent();
        renderSummary();
      } else {
        renderSummary(true);
        $("msg").textContent = "Fin des questions ‚Äî la synth√®se est √† droite ‚úÖ";
      }
      setHeader();
      setStepPills();
    }

    function back(){
      if(stepIndex > 0){
        stepIndex -= 1;
        renderCurrent();
        renderSummary();
      }
      setHeader();
      setStepPills();
    }

    function validate(){
      $("msg").textContent = "";
      const q = flow[ visibleSteps[stepIndex] ];
      const ans = collectCurrentAnswer();

      // Minimal validation: allow empty ONLY if user used "Je ne sais pas"
      let ok = true;
      if(q.type === "multi"){
        ok = ans.length > 0;
      }
      if(q.type === "single"){
        ok = !!ans;
      }
      if(q.type === "mixed"){
        ok = !!ans.radio; // checkbox alone isn't enough
      }
      if(q.type === "branch"){
        ok = !!ans.mode;
        if(ans.mode === "has"){
          ok = ok && !!ans.points && !!ans.cg; // require these if answered
        }
        if(ans.mode === "none"){
          ok = ok && !!ans.grip && !!ans.stab;
        }
      }

      if(!ok){
        $("msg").textContent = "Veuillez s√©lectionner une r√©ponse, ou utilisez ¬´ Je ne sais pas ¬ª.";
        $("msg").style.color = "var(--bad)";
        return;
      }

      saveAnswer(ans, false);

      // If action changed, rebuild visible steps now
      buildVisibleSteps();

      $("msg").textContent = "R√©ponse enregistr√©e ‚úÖ";
      $("msg").style.color = "var(--good)";

      next();
    }

    function dontKnow(){
      $("msg").textContent = "";
      saveAnswer(null, true);

      $("msg").textContent = "D‚Äôaccord ‚Äî on continue. (La pr√©cision de la demande baisse)";
      $("msg").style.color = "var(--warn)";
      next();
    }

    function renderSummary(forceFocus=false){
      const tb = $("summary");
      tb.innerHTML = "";

      const score = precisionScore();
      const cx = complexity();
      $("complexity").textContent = cx;

      const rows = [];

      // Action
      const actMap = { lift:"Lever", move:"D√©placer", hook:"Accrocher/saisir", support:"Pr√©voir une structure" };
      const act = state.action?.length ? state.action.map(x=>actMap[x]||x).join(", ") : "‚Äî";
      rows.push(["Action sur la charge", act]);

      // Movement
      if(state.action?.includes("move")){
        const mvMap = { vonly:"Vertical uniquement", h1:"Horizontal ‚Äî une direction", hmulti:"Horizontal ‚Äî plusieurs directions", tilt:"Incliner / basculer", flip:"Retourner (180¬∞)" };
        rows.push(["Mouvement", state.movement ? (mvMap[state.movement]||state.movement) : "‚Äî"]);
      }

      // Location
      if(state.action?.includes("lift") || state.action?.includes("move")){
        const locMap = { station:"Un poste d√©di√©", zone:"Une zone d√©finie", multi:"Plusieurs postes/zones" };
        const loc = state.location ? (locMap[state.location]||state.location) : "‚Äî";
        const ms = state["location_multisite"] ? " + multi-sites" : "";
        rows.push(["Localisation", loc + ms]);
      }

      // Hooking
      if(state.action?.includes("hook")){
        if(state.hooking && typeof state.hooking === "object"){
          if(state.hooking.mode === "has"){
            const ptsMap = { p1:"1 point", p2:"2 points", p3:"3 points", p4:"4 points" };
            const cgMap = { center:"CG centr√©", above_off:"CG d√©centr√©", below:"CG sous ancrages" };
            rows.push(["Accrochage", "Avec points d‚Äôancrage"]);
            rows.push(["Nombre de points", state.hooking.points ? (ptsMap[state.hooking.points]||state.hooking.points) : "‚Äî"]);
            rows.push(["Points d√©di√©s au levage", state.hooking.dedicated ? "Oui" : "Non"]);
            rows.push(["Centre de gravit√©", state.hooking.cg ? (cgMap[state.hooking.cg]||state.hooking.cg) : "‚Äî"]);
          } else if(state.hooking.mode === "none"){
            const gripMap = { positive:"Prise positive", clamp:"Serrage (pince)", suction:"Ventouses", mag:"Aimants" };
            const stabMap = { stable:"Stable", sensitive:"Sensible", unstable:"Instable" };
            rows.push(["Accrochage", "Sans points d‚Äôancrage"]);
            rows.push(["Mode de prise", state.hooking.grip ? (gripMap[state.hooking.grip]||state.hooking.grip) : "‚Äî"]);
            rows.push(["Stabilit√©", state.hooking.stab ? (stabMap[state.hooking.stab]||state.hooking.stab) : "‚Äî"]);
          } else {
            rows.push(["Accrochage", "‚Äî"]);
          }
        } else {
          rows.push(["Accrochage", "‚Äî"]);
        }
      }

      // Quality
      if(state.action?.includes("lift") || state.action?.includes("move") || state.action?.includes("hook")){
        const qMap = { simple:"Simple", precise:"Pr√©cise", very:"Tr√®s pr√©cise" };
        rows.push(["Pr√©cision attendue", state.quality ? (qMap[state.quality]||state.quality) : "‚Äî"]);
      }

      // Populate table
      rows.forEach(([a,b])=>{
        const tr = document.createElement("tr");
        tr.innerHTML = `<td>${esc(a)}</td><td>${esc(b)}</td>`;
        tb.appendChild(tr);
      });

      // Alerts (soft, sans encarts que tu veux supprimer)
      const alerts = [];
      if(state.movement === "flip") alerts.push("Retourner une charge : pr√©voir une validation technique sur la solution retenue.");
      if(state.movement === "tilt") alerts.push("Incliner/basculer : pr√©ciser l‚Äôangle attendu et la stabilit√© de la charge.");
      if(state.action?.includes("hook") && state.hooking?.mode === "has" && (state.hooking.points === "p3" || state.hooking.points === "p4")){
        alerts.push("Accrochage multipoints : pr√©ciser la r√©partition et les angles de levage.");
      }
      if(state.action?.includes("hook") && state.hooking?.mode === "has" && state.hooking.cg === "below"){
        alerts.push("Centre de gravit√© sous les ancrages : risque de basculement, pr√©ciser le sc√©nario.");
      }
      if(state["location_multisite"]) alerts.push("Multi-sites : pr√©ciser la mobilit√© attendue (transport, montage/d√©montage).");
      if(dontKnowCount.total>0) alerts.push("Certaines r√©ponses ne sont pas connues : la pr√©cision du cahier des charges est r√©duite.");

      const ul = $("alerts");
      ul.innerHTML = "";
      if(alerts.length===0){
        const li = document.createElement("li");
        li.textContent = "Aucune alerte √† ce stade.";
        ul.appendChild(li);
      } else {
        alerts.forEach(a=>{
          const li = document.createElement("li");
          li.textContent = a;
          ul.appendChild(li);
        });
      }

      // CDC text
      const cdcLines = [];
      cdcLines.push("CAHIER DES CHARGES ‚Äî PR√â-QUALIFICATION (LEVAGE)");
      cdcLines.push("");
      cdcLines.push(`Pr√©cision : ${score}%`);
      cdcLines.push(cx);
      cdcLines.push("");

      cdcLines.push("1) Ce que je dois faire");
      cdcLines.push(`- ${act}`);

      if(state.action?.includes("move")){
        const mvMap = { vonly:"Vertical uniquement", h1:"Horizontal ‚Äî une direction", hmulti:"Horizontal ‚Äî plusieurs directions", tilt:"Incliner / basculer", flip:"Retourner (180¬∞)" };
        cdcLines.push("");
        cdcLines.push("2) Mouvement attendu");
        cdcLines.push(`- ${state.movement ? (mvMap[state.movement]||state.movement) : "Non renseign√©"}`);
      }

      if(state.action?.includes("lift") || state.action?.includes("move")){
        const locMap = { station:"Un poste d√©di√©", zone:"Une zone d√©finie", multi:"Plusieurs postes/zones" };
        cdcLines.push("");
        cdcLines.push("3) Lieu / organisation");
        cdcLines.push(`- ${state.location ? (locMap[state.location]||state.location) : "Non renseign√©"}${state["location_multisite"] ? " (+ multi-sites)" : ""}`);
      }

      if(state.action?.includes("hook")){
        cdcLines.push("");
        cdcLines.push("4) Prise de la charge");
        if(state.hooking?.mode === "has"){
          const ptsMap = { p1:"1", p2:"2", p3:"3", p4:"4" };
          const cgMap = { center:"CG centr√©", above_off:"CG d√©centr√©", below:"CG sous ancrages" };
          cdcLines.push(`- Points d‚Äôancrage : ${state.hooking.points ? ptsMap[state.hooking.points] : "?"} point(s)`);
          cdcLines.push(`- Points d√©di√©s au levage : ${state.hooking.dedicated ? "Oui" : "Non"}`);
          cdcLines.push(`- Centre de gravit√© : ${state.hooking.cg ? (cgMap[state.hooking.cg]||state.hooking.cg) : "Non renseign√©"}`);
        } else if(state.hooking?.mode === "none"){
          const gripMap = { positive:"Prise positive", clamp:"Serrage (pince)", suction:"Ventouses", mag:"Aimants" };
          const stabMap = { stable:"Stable", sensitive:"Sensible", unstable:"Instable" };
          cdcLines.push("- Sans points d‚Äôancrage");
          cdcLines.push(`- Mode de prise : ${state.hooking.grip ? (gripMap[state.hooking.grip]||state.hooking.grip) : "Non renseign√©"}`);
          cdcLines.push(`- Stabilit√© : ${state.hooking.stab ? (stabMap[state.hooking.stab]||state.hooking.stab) : "Non renseign√©"}`);
        } else {
          cdcLines.push("- Non renseign√©");
        }
      }

      if(state.action?.includes("lift") || state.action?.includes("move") || state.action?.includes("hook")){
        const qMap = { simple:"Simple", precise:"Pr√©cise", very:"Tr√®s pr√©cise" };
        cdcLines.push("");
        cdcLines.push("5) Niveau de pr√©cision");
        cdcLines.push(`- ${state.quality ? (qMap[state.quality]||state.quality) : "Non renseign√©"}`);
      }

      cdcLines.push("");
      cdcLines.push("Remarques");
      if(alerts.length){
        alerts.forEach(a=>cdcLines.push(`- ${a}`));
      } else {
        cdcLines.push("- Aucune remarque √† ce stade.");
      }

      $("cdc").textContent = cdcLines.join("\n");

      if(forceFocus && window.innerWidth < 980){
        // on mobile, scroll a bit to show summary area
        document.querySelectorAll(".card")[1]?.scrollIntoView({behavior:"smooth", block:"start"});
      }

      setHeader();
      setStepPills();
    }

    function resetAll(){
      for(const k of Object.keys(state)) delete state[k];
      dontKnowCount.total = 0;
      dontKnowCount.byId = {};
      stepIndex = 0;
      buildVisibleSteps();
      renderCurrent();
      renderSummary();
    }

    function fillDemo(){
      resetAll();
      state.action = ["lift","move","hook","support"];
      state.movement = "hmulti";
      state.location = "multi";
      state["location_multisite"] = true;
      state.hooking = { mode:"has", points:"p4", dedicated:true, cg:"above_off" };
      state.quality = "precise";
      buildVisibleSteps();
      renderCurrent();
      renderSummary();
    }

    async function copyCDC(){
      const txt = $("cdc").textContent || "";
      $("msg").textContent = "";
      try{
        if(navigator.clipboard && window.isSecureContext){
          await navigator.clipboard.writeText(txt);
        } else {
          const ta=document.createElement("textarea");
          ta.value=txt; ta.style.position="fixed"; ta.style.left="-9999px";
          document.body.appendChild(ta); ta.select(); document.execCommand("copy"); ta.remove();
        }
        $("msg").textContent = "Cahier des charges copi√© ‚úÖ";
        $("msg").style.color = "var(--good)";
      }catch(e){
        $("msg").textContent = "Copie impossible : s√©lectionnez manuellement le texte.";
        $("msg").style.color = "var(--bad)";
      }
    }

    function downloadCDC(){
      const txt = $("cdc").textContent || "";
      const blob = new Blob([txt], {type:"text/plain;charset=utf-8"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href=url; a.download="cahier-des-charges-levage.txt";
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 1500);
    }

    function bind(){
      $("validateBtn").addEventListener("click", validate);
      $("dontKnowBtn").addEventListener("click", dontKnow);
      $("backBtn").addEventListener("click", back);
      $("skipToSummaryBtn").addEventListener("click", ()=>renderSummary(true));
      $("resetBtn").addEventListener("click", resetAll);
      $("demoBtn").addEventListener("click", fillDemo);

      $("copyBtn").addEventListener("click", copyCDC);
      $("downloadBtn").addEventListener("click", downloadCDC);
      $("callBtn").addEventListener("click", ()=>{
        alert("üëâ Contact sp√©cialiste : copiez le cahier des charges et envoyez-le au commercial.");
      });

      // Re-render if user changes branching (hooking first mode)
      document.addEventListener("change", (e)=>{
        const current = flow[ visibleSteps[stepIndex] ];
        if(current?.type === "branch"){
          // If user changes first mode, we should preserve state but re-render details live
          const q = current;
          const firstHas = $(`opt_${q.id}_first_has`)?.checked;
          const firstNone = $(`opt_${q.id}_first_none`)?.checked;
          if(firstHas || firstNone){
            const mode = firstHas ? "has" : "none";
            state[q.id] = state[q.id] || {};
            state[q.id].mode = mode;
            // Clear branch fields when switching
            if(mode === "has"){
              state[q.id].grip = null; state[q.id].stab = null;
            } else {
              state[q.id].points = null; state[q.id].cg = null; state[q.id].dedicated = false;
            }
            renderCurrent();
          }
        }
      });
    }

    // init
    buildVisibleSteps();
    bind();
    renderCurrent();
    renderSummary();
  </script>
</body>
</html>
